
// Global client-side utilities for GUI
function appState() {
  return { apiKey: localStorage.getItem('apiKey') || '', year: new Date().getFullYear(),
           saveKey() { localStorage.setItem('apiKey', this.apiKey || ''); alert('API key saved'); } };
}
document.addEventListener('htmx:configRequest', (e) => {
  const key = localStorage.getItem('apiKey') || '';
  if (key) e.detail.headers['X-API-Key'] = key;
});
async function authHeaders() {
  const key = localStorage.getItem('apiKey') || '';
  return key ? { 'X-API-Key': key, 'Content-Type':'application/json' } : { 'Content-Type':'application/json' };
}
function $(id) { return document.getElementById(id); }
function setPre(id, obj) { $(id).textContent = JSON.stringify(obj, null, 2); }
function parseCSV(str) { if (!str) return []; return str.split(',').map(s => s.trim()).filter(Boolean).map(s => Number.isNaN(+s) ? s : +s); }
async function loadRoot() { const res = await fetch('/'); const data = await res.json(); setPre('root-status', data); const el = document.getElementById('env-info'); if (el) el.textContent = `Env: ${data.environment} â€¢ Core:${data.features.core} ML:${data.features.ml} Redis:${data.features.redis}`; }
async function loadStats() { const res = await fetch('/api/stats', { headers: await authHeaders() }); setPre('stats', await res.json()); const live = document.getElementById('stats-live'); if (live) setPre('stats-live', await (await fetch('/api/stats', { headers: await authHeaders() })).json()); }
async function loadCatalog(cb) { const h = await authHeaders(); const gens = await (await fetch('/api/generators', { headers: h })).json(); const fns  = await (await fetch('/api/functions',  { headers: h })).json(); const genList = document.getElementById('gen-list'); const fnList = document.getElementById('fn-list'); if (genList) genList.innerHTML = (gens.all || []).map(g => `<li>${g}</li>`).join(''); if (fnList) fnList.innerHTML  = (fns.functions || []).map(f => `<li>${f}</li>`).join(''); const gsel = document.getElementById('generator'); const fsel = document.getElementById('function'); if (gsel) gsel.innerHTML = (gens.all || []).map(g => `<option>${g}</option>`).join(''); if (fsel) fsel.innerHTML = (fns.functions || []).map(f => `<option>${f}</option>`).join(''); if (cb) cb(); }
async function submitGenerate() { const payload = { generator: $('generator').value, function: $('function').value, parameters: $('params').value ? JSON.parse($('params').value) : null, count: parseInt($('count').value || '1'), verify: $('verify').checked, stream: $('stream').checked }; const res = await fetch('/api/generate', { method:'POST', headers: await authHeaders(), body: JSON.stringify(payload) }); const data = await res.json(); if (data.job_id) { $('progress').classList.remove('hidden'); trackJob(data.job_id, (update) => { const pct = Math.floor(update.progress || 0); $('progress-bar').style.width = pct + '%'; if ((update.status || '').toLowerCase() === 'completed') { $('progress').classList.add('hidden'); const tbody = $('results-table').querySelector('tbody'); tbody.innerHTML=''; (update.results || []).forEach((r,i) => { const tr=document.createElement('tr'); tr.innerHTML = `<td>${i+1}</td><td>${r.generator}</td><td>${r.function}</td><td><code>${r.ode}</code></td><td><code>${r.solution}</code></td><td>${r.verified}</td>`; tbody.appendChild(tr); }); }}); } else { alert('Failed to create job: ' + JSON.stringify(data)); } }
async function submitBatch() { const payload = { generators: parseCSV($('generators').value), functions: parseCSV($('functions').value), samples_per_combination: parseInt($('samples').value || '5'), parameter_ranges: { alpha: parseCSV($('alpha-range').value), beta: parseCSV($('beta-range').value), M: parseCSV($('M-range').value), q: parseCSV($('q-range').value), v: parseCSV($('v-range').value), a: parseCSV($('a-range').value) }, verify: $('verify').checked, save_dataset: $('save').checked, dataset_name: $('dataset-name').value || null }; const res = await fetch('/api/batch_generate', { method:'POST', headers: await authHeaders(), body: JSON.stringify(payload) }); const data = await res.json(); if (data.job_id) { $('job-status').classList.remove('hidden'); $('job-id').textContent = data.job_id; trackJob(data.job_id, (update) => { $('job-meta').textContent = JSON.stringify(update.metadata || {}, null, 2); const pct = Math.floor(update.progress || 0); $('job-progress').querySelector('.bar').style.width = pct + '%'; }); } else { alert('Failed to create batch job: ' + JSON.stringify(data)); } }
async function submitVerify() { const payload = { ode: $('ode').value, solution: $('solution').value, method: $('method').value }; const res = await fetch('/api/verify', { method:'POST', headers: await authHeaders(), body: JSON.stringify(payload) }); const data = await res.json(); setPre('verify-result', data); }
async function loadDatasets() { const data = await (await fetch('/api/datasets', { headers: await authHeaders() })).json(); const tbody = $('datasets-table').querySelector('tbody'); tbody.innerHTML=''; (data.datasets || []).forEach(d => { const tr = document.createElement('tr'); tr.innerHTML = `<td>${d.name}</td><td>${(d.size_bytes/1024).toFixed(1)} KB</td><td>${d.created_at}</td><td><a class="btn" href="/api/datasets/${d.name}/download?format=jsonl" target="_blank">JSONL</a> <a class="btn" href="/api/datasets/${d.name}/download?format=csv" target="_blank">CSV</a></td>`; tbody.appendChild(tr); }); }
async function loadJobs() { const status = $('job-filter') ? $('job-filter').value : ''; const url = status ? `/api/jobs?status=${encodeURIComponent(status)}` : '/api/jobs'; const data = await (await fetch(url, { headers: await authHeaders() })).json(); const tbody = $('jobs-table').querySelector('tbody'); tbody.innerHTML=''; (data.jobs || []).forEach(j => { const tr=document.createElement('tr'); const action = (j.status==='running' || j.status==='queued') ? `<button class="btn" onclick="cancelJob('${j.job_id}')">Cancel</button>` : ''; tr.innerHTML = `<td>${j.job_id}</td><td>${j.status}</td><td>${(j.progress||0).toFixed(1)}%</td><td>${j.updated_at}</td><td>${action}</td>`; tbody.appendChild(tr); }); }
async function cancelJob(jobId) { await fetch(`/api/jobs/${jobId}`, { method:'DELETE', headers: await authHeaders() }); loadJobs(); }
async function submitMLTrain() { const payload = { dataset: $('ml-dataset').value, model_type: $('ml-model').value, epochs: parseInt($('ml-epochs').value || '50'), batch_size: parseInt($('ml-batch').value || '32'), learning_rate: parseFloat($('ml-lr').value || '0.001'), validation_split: parseFloat($('ml-val').value || '0.2') }; const data = await (await fetch('/api/ml/train', { method:'POST', headers: await authHeaders(), body: JSON.stringify(payload) })).json(); setPre('ml-train-status', data); }
async function submitMLGenerate() { const payload = { model_path: $('gen-model-path').value, n_samples: parseInt($('gen-samples').value || '10'), temperature: parseFloat($('gen-temp').value || '0.8') }; const data = await (await fetch('/api/ml/generate', { method:'POST', headers: await authHeaders(), body: JSON.stringify(payload) })).json(); setPre('ml-gen-status', data); }
async function loadModels() { const data = await (await fetch('/api/ml/models', { headers: await authHeaders() })).json(); const tbody = $('models-table').querySelector('tbody'); tbody.innerHTML=''; (data.models || []).forEach(m => { const tr=document.createElement('tr'); tr.innerHTML = `<td>${m.name}</td><td>${(m.size_bytes/1024/1024).toFixed(2)} MB</td><td>${m.created_at}</td>`; tbody.appendChild(tr); }); }
let ws; function ensureWS() { if (ws && ws.readyState === WebSocket.OPEN) return ws; const id = localStorage.getItem('clientId') || (Math.random().toString(36).slice(2)); localStorage.setItem('clientId', id); ws = new WebSocket(`${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws/${id}`); ws.onclose = () => { setTimeout(ensureWS, 2000); }; return ws; }
window._jobHandlers = {}; async function trackJob(jobId, cb) { ensureWS(); try { ws.send(JSON.stringify({ type:'subscribe', topic:`job:${jobId}` })); } catch {} window._jobHandlers[jobId] = cb; const h = await authHeaders(); const poll = async () => { const data = await (await fetch(`/api/jobs/${jobId}`, { headers: h })).json(); cb(data); if (!['completed','failed','cancelled'].includes((data.status||'').toLowerCase())) { setTimeout(poll, 1500); } }; poll(); }
